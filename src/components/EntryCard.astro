---
import TagList from './TagList.astro';
import type { CollectionEntry } from 'astro:content';
import { render } from 'astro:content';

interface Props {
  entry: CollectionEntry<'entries'>;
  isHomepage?: boolean;
}

const { entry, isHomepage = false } = Astro.props;
const { data } = entry;
const { Content } = await render(entry);

const dateFormatted = data.date.toLocaleDateString('en-US', {
  month: 'long',
  day: 'numeric',
  year: 'numeric',
  timeZone: 'UTC',
});

const passageWordCount = data.passage.trim().split(/\s+/).length;
const isLongPassage = passageWordCount > 150;
---

<article class="entry-card">
  <time class="entry-date" datetime={data.date.toISOString().split('T')[0]}>
    {dateFormatted}
  </time>

  {!isHomepage && (
    <h1 class="entry-title">{data.title}</h1>
  )}

  {isHomepage && (
    <h2 class="entry-title">{data.title}</h2>
  )}

  <blockquote class={`entry-passage${isLongPassage ? ' entry-passage--long' : ''}`}>
    {data.passage.trim()}
  </blockquote>

  <p class="entry-attribution">
    <span class="author">{data.author}</span>, <cite>{data.source}</cite>{data.sourceYear ? ` (${data.sourceYear})` : ''}
    {data.excerpt && data.passageLink && (
      <span class="entry-excerpt-note"> · <a href={data.passageLink} rel="noopener noreferrer">Read the full text</a></span>
    )}
    {data.excerpt && !data.passageLink && (
      <span class="entry-excerpt-note"> · Excerpt</span>
    )}
  </p>

  <div class="section-ornament" aria-hidden="true">* * *</div>

  <div class="entry-commentary">
    <Content />
  </div>

  <TagList tags={data.tags} />
</article>

<script>
let observer: IntersectionObserver | null = null;

document.addEventListener('astro:page-load', () => {
  // Clean up previous observer (e.g. navigated away before scrolling through all elements)
  if (observer) {
    observer.disconnect();
    observer = null;
  }

  if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

  const ornament = document.querySelector('.section-ornament');
  const paragraphs = document.querySelectorAll('.entry-commentary > p');
  if (!ornament && paragraphs.length === 0) return;

  observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          entry.target.classList.add('revealed');
          observer!.unobserve(entry.target);
        }
      });
    },
    { threshold: 0.2 },
  );

  // Ornament unfurl — skip if already in viewport
  if (ornament) {
    const rect = ornament.getBoundingClientRect();
    if (rect.top >= window.innerHeight) {
      ornament.setAttribute('data-unfurl', '');
      observer.observe(ornament);
    }
  }

  // Commentary paragraphs — skip those already in viewport
  paragraphs.forEach((p) => {
    const rect = p.getBoundingClientRect();
    if (rect.top >= window.innerHeight) {
      p.setAttribute('data-reveal', '');
      observer!.observe(p);
    }
  });
});
</script>
